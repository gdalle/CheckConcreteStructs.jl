var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Public","page":"API reference","title":"Public","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [CheckConcreteStructs]\nPrivate = false","category":"page"},{"location":"api/#CheckConcreteStructs.CheckConcreteStructs","page":"API reference","title":"CheckConcreteStructs.CheckConcreteStructs","text":"CheckConcreteStructs\n\nLightweight package to check that types are defined with concrete fields.\n\nExports\n\nall_concrete\n@check_concrete\n\n\n\n\n\n","category":"module"},{"location":"api/#CheckConcreteStructs.all_concrete-Tuple{Any}","page":"API reference","title":"CheckConcreteStructs.all_concrete","text":"all_concrete(T::Type; verbose=true)\n\nReturn true if type T has only concretely-typed fields.\n\nIf verbose=true, any field with an abstract type will display a warning.\n\nExamples\n\nTypes with abstract fields:\n\njulia> using CheckConcreteStructs\n\njulia> struct Bad1; x; end  # missing annotation\n\njulia> all_concrete(Bad1; verbose=false)\nfalse\n\njulia> struct Bad2; x::AbstractVector; end  # abstract container\n\njulia> all_concrete(Bad2; verbose=false)\nfalse\n\njulia> struct Bad3; x::Vector{<:Real}; end  # abstract element type\n\njulia> all_concrete(Bad3; verbose=false)\nfalse\n\njulia> struct Bad4; x::Array{Float64}; end  # not enough type parameters\n\njulia> all_concrete(Bad4; verbose=false)\nfalse\n\nTypes with only concrete fields:\n\njulia> using CheckConcreteStructs\n\njulia> struct Good1; x::Vector{Float64}; end\n\njulia> all_concrete(Good1)\ntrue\n\njulia> struct Good2{T<:Real}; x::Vector{T}; end\n\njulia> all_concrete(Good2)\ntrue\n\njulia> struct Good3{T<:Real,V<:AbstractVector{T}}; x::V; end\n\njulia> all_concrete(Good3)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"api/#CheckConcreteStructs.all_concrete-Tuple{Module}","page":"API reference","title":"CheckConcreteStructs.all_concrete","text":"all_concrete(M::Module; verbose=true)\n\nReturn true if every type defined inside the module M has only concretely-typed fields.\n\nIf verbose=true, any field with an abstract type will display a warning.\n\nwarning: Warning\nThis function does not handle submodules yet.\n\n\n\n\n\n","category":"method"},{"location":"api/#CheckConcreteStructs.@check_concrete-Tuple{Expr}","page":"API reference","title":"CheckConcreteStructs.@check_concrete","text":"@check_concrete struct MyType\n    # fields\nend\n\nCheck that every field of a struct definition is concretely typed, throw an error if that is not the case.\n\nExamples\n\nTypes with abstract fields:\n\njulia> using CheckConcreteStructs\n\njulia> @check_concrete struct Bad1; x; end  # missing annotation\nERROR: AbstractFieldError in struct `Bad1`: field `x` with declared type `Any` is not concretely typed.\n\njulia> @check_concrete struct Bad2; x::AbstractVector; end  # abstract container\nERROR: AbstractFieldError in struct `Bad2`: field `x` with declared type `AbstractVector` is not concretely typed.\n\njulia> @check_concrete struct Bad3; x::Vector{<:Real}; end  # abstract element type\nERROR: AbstractFieldError in struct `Bad3`: field `x` with declared type `Vector{<:Real}` is not concretely typed.\n\njulia> @check_concrete struct Bad4; x::Array{Float64}; end  # not enough type parameters\nERROR: AbstractFieldError in struct `Bad4`: field `x` with declared type `Array{Float64}` is not concretely typed.\n\nTypes with only concrete fields:\n\njulia> using CheckConcreteStructs\n\njulia> @check_concrete struct Good1; x::Vector{Float64}; end\ntrue\n\njulia> @check_concrete struct Good2{T<:Real}; x::Vector{T}; end\ntrue\n\njulia> @check_concrete struct Good3{T<:Real,V<:AbstractVector{T}}; x::V; end\ntrue\n\n\n\n\n\n","category":"macro"},{"location":"api/#Private","page":"API reference","title":"Private","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [CheckConcreteStructs]\nPublic = false","category":"page"},{"location":"#CheckConcreteStructs.jl","page":"Home","title":"CheckConcreteStructs.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Dev Documentation) (Image: Coverage) (Image: Code Style: Blue)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Faulty or missing type declarations, especially for struct fields, are a common performance pitfall in Julia. This package allows you to check that the structs you work with have concretely-typed fields.","category":"page"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install CheckConcreteStructs.jl from the GitHub URL:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/gdalle/CheckConcreteStructs.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"The main exports of this package are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"the function all_concrete, which can be used on an existing type or module\nthe macro @check_concrete, which can be used before a struct definition","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please read their docstrings for examples.","category":"page"},{"location":"#Related-packages","page":"Home","title":"Related packages","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"ConcreteStructs.jl exports a macro @concrete which adds all the necessary type parameters to a struct definition. In other words:","category":"page"},{"location":"","page":"Home","title":"Home","text":"CheckConcreteStructs.jl tells you how to fix problems when they occur.\nConcreteStructs.jl prevents them from occurring at all (in a slightly more opaque way).","category":"page"}]
}
